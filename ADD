PROJETO APOIOJ√Å ‚Äî ROTEIRO DE QUALITY ASSURANCE 

Objetivo geral

O ApoioJ√° √© uma aplica√ß√£o web criada em Flask (Python) que permite o registro an√¥nimo de den√∫ncias de situa√ß√µes de risco ou vulnerabilidade e oferece um chatbot inteligente de acolhimento, baseado em IA emp√°tica (Google Gemini ou modo simulado).

O objetivo desta fase √© que os alunos de Quality Assurance:
1 - Compreendam a estrutura t√©cnica do sistema (Fases 1 e 2);
2 - Planejem e executem testes unit√°rios, funcionais, de usabilidade e de performance;
3 - Apliquem boas pr√°ticas de QA.

VIS√ÉO GERAL DA ARQUITETURA
apoioja/
‚îÇ
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py           ‚Üí configura√ß√£o do app Flask
‚îÇ   ‚îú‚îÄ‚îÄ models.py             ‚Üí modelo do banco de dados (tabela de den√∫ncias)
‚îÇ   ‚îú‚îÄ‚îÄ routes.py             ‚Üí rotas de navega√ß√£o e API (inclui /api/chat)
‚îÇ   ‚îú‚îÄ‚îÄ chatbot.py            ‚Üí integra√ß√£o com IA Gemini + fallback
‚îÇ   ‚îú‚îÄ‚îÄ static/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ style.css         ‚Üí estilos visuais (layout, chatbot, bot√µes)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ apoioja_banner.png
‚îÇ   ‚îî‚îÄ‚îÄ templates/
‚îÇ       ‚îú‚îÄ‚îÄ index.html        ‚Üí p√°gina inicial (apresenta√ß√£o)
‚îÇ       ‚îî‚îÄ‚îÄ denuncia.html     ‚Üí p√°gina do formul√°rio de den√∫ncias + mapa + chatbot
‚îÇ
‚îú‚îÄ‚îÄ apoioja.db                ‚Üí banco SQLite local
‚îú‚îÄ‚îÄ run.py                    ‚Üí ponto de entrada do Flask
‚îú‚îÄ‚îÄ requirements.txt           ‚Üí depend√™ncias do projeto
‚îî‚îÄ‚îÄ .env                      ‚Üí chave GEMINI_API_KEY (opcional)

FASE 1 ‚Äî CONSTRU√á√ÉO E FUNCIONAMENTO B√ÅSICO DO SISTEMA
Objetivo
- Construir a base da aplica√ß√£o ApoioJ√°, com:
- Front-end (HTML, CSS, JS)
- Back-end (Python + Flask)
- Banco de dados SQLite
- P√°gina de den√∫ncia funcional com envio e limpeza dos dados

Etapas de implementa√ß√£o (n√£o esquecer de respeitar o esquema de pastas descrita acima)
1. Configura√ß√£o inicial
- Na linha de comando (ws ou vscode)
mkdir apoioja
cd apoioja
python.exe -m pip install --upgrade pip
pip install flask flask_sqlalchemy python-dotenv


2. Criar arquivo do Banco de dados (SQLite):
/apoioja/app/models.py

from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class Report(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    category = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text, nullable=False)
    location = db.Column(db.String(100), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)


3. Aruivo de Inicializa√ß√£o do app
/apoioja/app/__init__.py

from flask import Flask
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

def create_app():
    app = Flask(__name__)
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///apoioja.db'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    db.init_app(app)

    with app.app_context():
        from . import routes
        db.create_all()

    return app


/apoioja/run.py:

from app import create_app
app = create_app()

if __name__ == "__main__":
    app.run(debug=True)

4. Arquivo de Rotas e p√°ginas
/apoioja/app/routes.py:

from flask import render_template, request, jsonify
from .models import db, Report

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/denuncia")
def denuncia():
    return render_template("denuncia.html")

@app.route("/api/reports", methods=["POST"])
def api_reports():
    data = request.get_json()
    new_report = Report(
        category=data["category"],
        description=data["description"],
        location=data["location"]
    )
    db.session.add(new_report)
    db.session.commit()
    return jsonify({"message": "Den√∫ncia registrada com sucesso."})
@app.route("/api/reports", methods=["GET"])
def get_reports():     
    reports = Report.query.all()
    reports_list = [
        {
            "id": report.id,
            "category": report.category,
            "description": report.description,
            "location": report.location,
            "created_at": report.created_at
        }
        for report in reports
    ]
    return jsonify(reports_list)


5. Front-end (Formul√°rio)
/apoioja/app/templates/denuncia.html

Formul√°rio com campos Categoria, Local, Descri√ß√£o

Bot√µes ‚ÄúEnviar Den√∫ncia‚Äù, ‚ÄúLimpar Campos‚Äù, ‚ÄúEsconder‚Äù

Mapa mockado (imagem est√°tica)

Banner do ApoioJ√°

6. CSS da interface

static/style.css define:

Fundo azul claro

Formul√°rio centralizado

Banner superior

Mapa e bot√µes estilizados

Fontes leg√≠veis e responsivas

7. Verifica√ß√£o do banco
python
>>> from app import create_app, db
>>> from app.models import Report
>>> app = create_app()
>>> app.app_context().push()
>>> db.session.query(Report).count()
0


Se n√£o houver erro, o banco est√° criado corretamente.

FASE 2 ‚Äî INTEGRA√á√ÉO DO CHATBOT INTELIGENTE

Objetivo: Integrar um chatbot emp√°tico baseado na IA Gemini, com modo offline (fallback), widget flutuante e rota de API.

Etapas de implementa√ß√£o
1. Instalar depend√™ncias
pip install python-dotenv google-generativeai

2. Criar .env

Na raiz do projeto:

GEMINI_API_KEY=sua_chave_aqui


Se n√£o houver chave, o chatbot usa modo offline.

3. Criar arquivo app/chatbot.py

(C√≥digo completo entregue na aula ‚Äî inclui fallback)

4. Adicionar rota /api/chat em routes.py

Permite comunica√ß√£o entre o front-end e o modelo de IA.

5. Inserir o widget do chatbot no front-end

No final de index.html e denuncia.html, antes de </body>, inserir:

HTML do chat (div + bot√£o üí¨)

Script JS de controle de abertura, envio e exibi√ß√£o das mensagens.

6. Garantir o CSS do chatbot

Adicionar ao style.css (no final):

.chatbot, .chat-toggle, .chat-header, .user-msg, .bot-msg, etc.

7. Teste funcional

Inicie o servidor:

python run.py


Acesse http://127.0.0.1:5000

Clique no bot√£o üí¨ no canto inferior direito.

Envie uma mensagem.

Se o Gemini estiver ativo ‚Üí resposta real de IA.

Se n√£o ‚Üí mensagem de fallback (emp√°tica).


FASE DE QA ‚Äî TESTES E VALIDA√á√ÉO
Objetivo

Garantir que o sistema ApoioJ√° funcione corretamente e com qualidade sob todos os cen√°rios.

1Ô∏è‚É£ TESTES UNIT√ÅRIOS
Ferramenta
pytest

Arquivo sugerido: tests/test_app.py
import json

def test_index(client):
    resp = client.get('/')
    assert resp.status_code == 200

def test_report_creation(client):
    data = {"category":"teste","description":"desc","location":"local"}
    resp = client.post('/api/reports', data=json.dumps(data), content_type='application/json')
    assert resp.status_code == 200
    assert b"sucesso" in resp.data

def test_chat_api(client):
    resp = client.post('/api/chat', json={"message":"oi"})
    assert resp.status_code == 200
    assert "reply" in resp.get_json()

2Ô∏è‚É£ TESTES DE USABILIDADE

Verificar:
1 - Bot√µes ‚ÄúEnviar‚Äù, ‚ÄúLimpar‚Äù e ‚ÄúEsconder‚Äù funcionam corretamente.
2 - Ap√≥s o envio, os campos s√£o limpos automaticamente.
3 - Chatbot abre e fecha facilmente.
4 - As cores s√£o harmoniosas e acess√≠veis (contraste adequado).

Ferramentas:
Inspe√ß√£o com ferramenta

3Ô∏è‚É£ TESTES DE INTEGRA√á√ÉO
Cen√°rio:
1 - Enviar uma den√∫ncia ‚Üí verificar registro no banco.
2 - Abrir chatbot ‚Üí enviar mensagem ‚Üí receber resposta.
3 - confirmar resposta fallback.


4Ô∏è‚É£ TESTES DE PERFORMANCE
Objetivo:

Avaliar tempo de resposta das rotas:

/api/reports
/api/chat

Ferramenta sugerida:
Apache Benchmark (ab)

Exemplo:

ab -n 50 -c 10 http://127.0.0.1:5000/api/chat

5Ô∏è‚É£ TESTES DE SEGURAN√áA
Pontos de verifica√ß√£o:

1 - Nenhum dado pessoal sens√≠vel armazenado no banco.
2 - A chave GEMINI_API_KEY n√£o aparece em logs ou c√≥digo p√∫blico.
3 - Formul√°rios escapam HTML (XSS protegido).
4- Chatbot n√£o permite scripts no input (escapeHtml() no JS previne isso).

6Ô∏è‚É£ CI/CD
Configurar GitHub Actions:
name: ApoioJa CI
on: [push]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: 3.11
      - run: pip install -r requirements.txt
      - run: pytest


RELAT√ìRIO FINAL DE QA

Cada grupo deve entregar:

- Plano de testes (unit√°rio, funcional, usabilidade, performance).
- Evid√™ncias de execu√ß√£o (prints, logs ou relat√≥rios de ferramenta).
- Execu√ß√£o CI/CD autom√°tica.

RESULTADOS ESPERADOS
‚úÖ Aplica√ß√£o funcional com formul√°rio e chatbot
‚úÖ Testes de API e UI documentados
‚úÖ Boas pr√°ticas de QA aplicadas
‚úÖ Uso seguro de dados
‚úÖ Relat√≥rio t√©cnico com evid√™ncias de testes
